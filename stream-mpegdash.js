const child_process = require('child_process');
const assert = require('assert');
const fs = require('fs');
const path = require('path');
const config = require('./config.js');
const Promise = require('./promise.js');

// Mpeg DASH -- Dynamic Adaptive Streaming over HTTP (https://github.com/Dash-Industry-Forum/dash.js/wiki)
// this method is called in response to a request for mpeg dash manifest that does not exist yet.
// this camera instance has been identified as the one to generate the manifest and webm chunks.
// two ffmpeg processes will be run. the first one runs forever until explicitly killed. this first
// ffmpeg process generates the webm chunks and header files. then a second ffmpeg process runs that
// uses the header files generated by the first ffmpeg process to generate an mpeg dash manifest.
class MpegDashStream {
	constructor(name, rtspUrl) {
		this.name = name;
		this.rtspUrl = rtspUrl;
		this.promises = [];
	}

	generateManifest(clientReq, clientRes, pathname) {
		var self = this;
		var promise = new Promise();
		self.promises.push(promise);
		if (self.dashProcess) {
			// another client has initiated the manifest generation
			assert(this.promises.length > 1);
			return promise;
		}
		self.deleteFolderRecursive(path.join(config.WWW_ROOT, config.WEBM_CACHE, self.name)); // this folder is not expected to exist. assert instead?
		fs.mkdir(path.join(config.WWW_ROOT, config.WEBM_CACHE, self.name), function(error) {
			if (error)
				return self.fullfillPromises(error, null);
			// run first ffmpeg command to generate chunks and header files, this process will keep running
			// to generate chunks continuously.
			self.dashProcess = child_process.spawn("ffmpeg", [ '-rtsp_transport', 'tcp', '-i', self.rtspUrl,
				'-map', '0:0', '-c:v', 'libvpx-vp9', '-keyint_min', '40', '-g', '40', '-r', '20', '-speed', '5', '-tile-columns', '4', '-qmin', '4', '-qmax', '48',
				'-frame-parallel', '1', '-threads', '8', '-static-thresh', '0', '-max-intra-rate', '300', '-deadline', 'realtime',
				'-lag-in-frames', '0', '-error-resilient', '1', '-f', 'webm_chunk', '-header', config.WEBM_CACHE + '/' + self.name + '/' + 'glass_360.hdr',
				'-chunk_start_index', '1', config.WEBM_CACHE + '/' + self.name + '/' + 'glass_360_%d.chk', '-map', '0:1', '-c:a', 'libopus', '-f', 'webm_chunk',
				'-audio_chunk_duration', '2000', '-header', config.WEBM_CACHE + '/' + self.name + '/' + 'glass_171.hdr', '-chunk_start_index', '1',
				config.WEBM_CACHE + '/' + self.name + '/' + 'glass_171_%d.chk' ], {
				detached: false,
				cwd: config.WWW_ROOT
			});
			self.dashProcess.stderr.on('data', function(data) {
				//console.log('dashProcess.stderr: ', data.toString());
			});
			self.dashProcess.stdout.on('data', function(data) {
				//console.log('dashProcess.stdout: ', data.toString());
			});
			self.dashProcess.on('error', function(error) {
				self.terminate();
			});
			self.dashProcess.on('exit', function(code, signal) {
				self.terminate();
			});
			// wait 10s for header files to be generated as these are the required inuput for the second ffmpeg command
			setTimeout(function() {
				if (!fs.existsSync(path.join(config.WWW_ROOT, config.WEBM_CACHE, self.name, 'glass_360.hdr'))) {
					self.fullfillPromises({'message':'Failed to generate headers'}, null);
					return self.terminate();
				}
				// run second ffmpeg command to generate manifest. this command exits immediately after manifest is generated
				// NOTE: do not use path.join to form the path arguments for this ffmpeg command or the generated manifest will contains invalid paths
				//       ffmpeg command doesn't like '\' as path separator
				self.dashManifestProcess = child_process.spawn("ffmpeg", [ '-f', 'webm_dash_manifest', '-live', '1',
					'-i', config.WEBM_CACHE + '/' + self.name + '/' + 'glass_360.hdr', '-f', 'webm_dash_manifest', '-live', '1', '-i',
					config.WEBM_CACHE + '/' + self.name + '/' + 'glass_171.hdr', '-c', 'copy', '-map', '0', '-map', '1', '-f', 'webm_dash_manifest',
					'-live', '1', '-adaptation_sets', 'id=0,streams=0 id=1,streams=1', '-chunk_start_index', '1',
					'-chunk_duration_ms', '2000', '-time_shift_buffer_depth', '7200', '-minimum_update_period', '7200',
					config.WEBM_CACHE + '/' + self.name + '/' + 'glass_live_manifest.mpd' ], {
					detached: false,
					cwd: config.WWW_ROOT
				});
				self.dashManifestProcess.stderr.on('data', function(data) {
					console.log('dashManifestProcess.stderr: ', data.toString());
				});
				self.dashManifestProcess.stdout.on('data', function(data) {
					console.log('dashManifestProcess.stdout:', data.toString());
				});
				self.dashManifestProcess.on('error', function(error) {
					self.terminate();
					self.fullfillPromises(error, null);
				});
				// second ffmpeg command is expected to exit when the manifest file has been generated.
				// check for success exit code (0) and invoke the callback to return the manifest to client.
				self.dashManifestProcess.on('exit', function(code, signal) {
					// check self.dashManifestProcess as  the 'error' event above may have fired and callback already called
					if (!self.dashManifestProcess)
						return;
					if (code === 0)
						return self.fullfillPromises(null, config.WWW_ROOT + '/' + config.WEBM_CACHE + '/' + self.name + '/' + 'glass_live_manifest.mpd'); // success
					// failure: exit code != 0
					self.fullfillPromises({'message':'Failed to generate manifest'}, null);
					self.terminate();
				});
			}, 10000);
			//setTimeout(self.checkCleanup.bind(self), 60000);
		});
		return promise;
	}
	
	fullfillPromises(error, result) {
		this.promises.forEach(function(promise) {
			promise.fullfill(error, result);
		});
		this.promises = [];
	}
	
	// update dashChunkRequested flag that the checkCleanup timer checks every interval 
	checkRequest(clientReq) {
		if (clientReq.url.match('^/' + config.WEBM_CACHE + '/' + this.name + '/.*?\.chk$'))
			this.dashChunkRequested = true;
	}
	
	// if no requests come in for webm chunk when timer expires then kill ffmpeg dash process and cleanup
	checkCleanup() {
		if (!this.dashChunkRequested)
			return this.terminate();
		this.dashChunkRequested = false; // reset flag
		setTimeout(this.checkCleanup.bind(this), 60000); // and check again in 1 minute
	}
	
	// kill the ffmpeg process that generates webm chunks and delete the entire output folder
	terminate() {
		if (this.dashManifestProcess) {
			this.dashManifestProcess.kill('SIGTERM');
			delete this.dashManifestProcess;
		}
		if (this.dashProcess) {
			this.dashProcess.kill('SIGTERM');
			delete this.dashProcess;
		}
		this.deleteFolderRecursive(path.join(config.WWW_ROOT, config.WEBM_CACHE, this.name));
		this.fullfillPromises({'message':'stream terminated'}, null);
	}
	
	deleteFolderRecursive(path) {
		if (fs.existsSync(path)) {
			fs.readdirSync(path).forEach(function(file, index) {
				var curPath = path + "/" + file;
				if (fs.lstatSync(curPath).isDirectory()) { // recurse
					this.deleteFolderRecursive(curPath);
				} else { // delete file
					fs.unlinkSync(curPath);
				}
			});
			fs.rmdirSync(path);
		}
	}
}

module.exports = MpegDashStream;
